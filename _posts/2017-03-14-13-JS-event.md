---
layout: post
title: "js事件处理程序相关"
date: 2017-03-19
excerpt: "事件兼容接口，事件处理程序及作用域"
tag:
- javascript

comments: false
---
# 一、 事件处理程序
## 1、HTML事件处理程序
	<button onclick = "save(event,this)">submit</button>

- DOM0级事件传送参数必须是`event`全拼，`e`不行。
- `function save(){}`必须写在全局，作为全局函数，否则报错。

- e.target 或者e.srcElement指触发事件的实际元素

## 2、DOM0级事件处理程序(IE5)

	var btn = document.getElementById("btn");
	btn.onclick = function(){
	alert(this.id);//btn
	}

	btn.onclick = null//删除事件处理程序

## 3、DOM2级事件处理程序（非IE和IE9）
	
	btn.addEventListener("click",handler,false);

	btn.removeEventListener("click",handler,false);//移除，传入必须与add参数相同

DOM2级的方法添加好处：可以添加多个事件处理程序，按照顺序响应。

通过addEventListener()添加事件处理程序只能用removeEventListener()移除，参数与添加时相同，**通过addEventListener()添加的匿名函数将无法移除。**

*tips:上述三种事件中`this`指绑定事件处理程序的DOM元素*
## 4、IE中的事件绑定(IE6-IE8)

	btn.attachEvent("onclick",dev);//this === window
	
在IE中使用DOM0和`attachEvent()`主要区别在于事件处理程序的作用域

- DOM0级：事件处理程序会在其所在元素的作用域内运行
- attachEvent():会在全局作用域内运行

so , 在IE6-8事件中慎用this.

## 5.事件模型
### DOM标准事件模型

DOM标准同时支持两种事件模型，即**捕获型事件**与**冒泡型事件** AddEventListener("click",handler,false);
DOM事件模型包含捕获阶段和冒泡阶段，IE事件模型只包含冒泡阶段；
DOM事件模型可使用e.stopPropagation()来阻止事件流。

javascript中有两种事件模型：DOM0，DOM2（标准事件模型）。

### IE事件模型
IE事件模型只包含冒泡阶段；

<pre>
Dom事件模型：捕获/冒泡阶段
ele.addEventListener(type,handler,false)/removeEventListener(type,handler,false)
e.target,    e.preventDefault(),    e.stopPropagation()
IE事件模型：冒泡阶段
e.attachEvent(“on”+type,handler)/e.detachEvent(“on”+handler);
e.srcElement; e.returnValue = false; e.cancelBubble = true;
</pre>

# 二、事件兼容接口
	
	var EventUtil = {
	
		//绑定事件
		addHandler: function(ele, type, handler) {
			if(ele.addEventListener) {
				ele.addEventListener(type, handler, false); //非IE和IE9
			} else if(ele.attachEvent) {
				ele.attachEvent("on" + type, handler); //IE6-8
			} else {
				ele["on" + type] = handler; //IE5
			}
		},
	
		//移除某类型事件,handler要与addHandle中一致
		removeHandler: function(ele, type, handler) {
			if(ele.removeEventListener) {
				ele.removeEventListener(type, handler);
			} else if(ele.detachEvent) {
				ele.detachEvent("on" + type, handler);
			} else {
				ele["on" + type] = null;
			}
		},
	
		getEvent: function(event) {
			return event ? event : window.event;
		},
	
		getTarget: function(event) {
			return event.target || event.srcElement;
		},
	
		//取消事件的默认行为
		preventDefault: function(event) {
			if(event.preventDefault) {
				event.preventDefault();
			} else {
				event.returnValue = false;
			}
		},
	
		//阻止事件流
		stopPropagation: function(event) {
			if(event.stopPropagation) {
				event.stopPropagation();
			} else {
				event.cancelBubble = true;
			}
		}
	
	};


# 三、事件作用域问题：

## 1. 事件作用域

- 事件内定义的变量，在事件结束销毁（再次进入事件undefined）
- 事件外变量，一直在内存中（有点像闭包？）

## 2. 如何传参和返回值
传参：在处理事件程序中另外调用函数，并传递`e`和参数：

	funtion checkUsername(e){
	checkUsername(e,5);
	}

返回值：在事件处理程序外定义变量，操作该变量作为返回值。

## 2. 事件的内存和性能：

js中添加到页面的事件处理程序数量直接影响整体运行性能，

#### 事件数量如何影响性能：

1. 每个函数都是对象，都会占用内存，内存对象越多，性能越差；
2. 必须事先指定所有事件处理程序而导致：`DOM访问次数`，会延迟整个页面交互就绪时间。

#### 如何减少事件数量：

- 方法1 ：**事件委托**，利用了事件冒泡，只指定一个时间处理程序，就可以管理某一类型的所有事件。限制建立连接数量，占用更少内存，提高性能。
- 方法2：手动移除时间处理程序，减少链接数量，确保内存可以再次被利用。如用`innerHTML`删除元素前将元素解绑;纯`Dom`操作移除  `removeChild()`等已将事件解绑，无需再解绑

