---
layout: post
title: "node.js系列笔记—koa2 API "
date: 2017-07-01
excerpt: "koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。"
tag:
- React.js
- Koa2
- node.js

comments: false
---
## 零、ECMAScript基础

### 1、Promise

	new Promise( /* executor */ function(resolve, reject) { ... } );
	
	.then(resolve,reject)
    .then(function(){})
    .catch(function(){})
   
a function with promise functionality

	function myAsyncFunction(url) {
	  return new Promise((resolve, reject) => {
	    const xhr = new XMLHttpRequest();
	    xhr.open("GET", url);
	    xhr.onload = () => resolve(xhr.responseText);
	    xhr.onerror = () => reject(xhr.statusText);
	    xhr.send();
	  });
	});
更多来源：<a href = 'https://segmentfault.com/a/1190000002928371'>更多</a>

### 2、Generator
Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。

	function* gen(x){
	  var y = yield x + 2;
	  return y;
	}
	
	var g = gen(1);
	g.next() // { value: 3, done: false }
	g.next() // { value: undefined, done: true }
	
上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即`执行它不会返回结果`，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 `yield` 语句，上例是执行到 x + 2 为止。

换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。

参考：<a href='http://www.ruanyifeng.com/blog/2015/04/generator.html'>Generator 函数的含义与用法（阮一峰）</a>


#### Thunk 函数的含义和用法
thunk函数是`传名调用`的一种实现策略，函数的参数到底应该何时求值，即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。

	f(x + 5)
	// 传名调用时，等同于
	(x + 5) * 2

	// 正常版本的readFile（多参数版本）
	fs.readFile(fileName, callback);
	
	//trunk js 实现
	var Thunk = function (fileName){
	  return function (callback){
	    return fs.readFile(fileName, callback); 
	  };
	};
	
	// Thunk版本的readFile（单参数版本）
	var readFileThunk = Thunk(fileName);
	readFileThunk(callback);
	
Thunkify

	$ npm install thunkify
	
	function f(a, b, callback){
	  var sum = a + b;
	  callback(sum);
	  callback(sum);
	}
	
	var ft = thunkify(f);
	ft(1, 2)(console.log); 
	// 3

#### co 函数库的含义和用法
co 函数库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。Generator 函数只要传入 co 函数，就会自动执行。co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。

	var gen = function* (){
	  var f1 = yield readFile('/etc/fstab');
	  var f2 = yield readFile('/etc/shells');
	  console.log(f1.toString());
	  console.log(f2.toString());
	};
	
	var co = require('co');
	co(gen);
	
	co(gen).then(function (){
	  console.log('Generator 函数执行完成');
	})

参考：<a href='http://www.ruanyifeng.com/blog/2015/05/co.html'>co 函数库的含义和用法（阮一峰）</a>

### 3. Async await
async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。

	async function fn(args){
	  // ...
	}
	
	// 等同于
	
	function fn(args){ 
	  return spawn(function*() {
	    // ...
	  }); 
	}
async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。

优点：（1）内置执行器。 （2）更好的语义。（3）更广的适用性
来源：<a href='http://www.ruanyifeng.com/blog/2015/05/async.html'>async 函数的含义和用法（阮一峰）</a>

## 一、Koa2的前世今生

异步实现(ES5-ES6-ES7)：回调 －> generator -> async await
#### 1. express
Express是第一代最流行的web框架，它对Node.js的`http`进行了封装，用起来如下：

	var express = require('express');
	var app = express();
	
	app.get('/', function (req, res) {
	    res.send('Hello World!');
	});
	
	app.listen(3000, function () {
	    console.log('Example app listening on port 3000!');
	});
	
虽然Express的API很简单，但是它是基于`ES5`的语法，要实现异步代码，只有一个方法：`回调`。如果异步嵌套层次过多，代码写起来就非常难看.

	app.get('/test', function (req, res) {
    fs.readFile('/file1', function (err, data) {
        if (err) {
            res.status(500).send('read file1 error');
        }
        fs.readFile('/file2', function (err, data) {
            if (err) {
                res.status(500).send('read file2 error');
            }
            res.type('text/plain');
            res.send(data);
        });
    	});
	});
	
虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了！

### 2. koa 1.0
  随着新版Node.js开始支持ES6，Express的团队又基于`ES6`的`generator`重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：

	var koa = require('koa');
	var app = koa();
	
	app.use('/test', function *() {
	    yield doReadFile1();
	    var data = yield doReadFile2();
	    this.body = data;
	});
	
	app.listen(3000);

用generator实现异步比回调简单了不少，但是`generator`的本意并不是异步。`Promise`才是为异步设计的，但是Promise的写法……想想就复杂。

### 3. koa 2.*
  为了简化异步代码，`ES7`（目前是草案，还没有发布）引入了新的关键字`async`和`await`，可以轻松地把一个function变为异步模式：

	async function () {
	    var data = await fs.read('/file1');
	}

这是JavaScript未来标准的异步代码，非常简洁，并且易于使用。

	Koa是http中间件架构(middleware framwork)，专注于提供和创建http服务器有关的通用方法和属性，本身不绑定任何中间件，有开源社区提供实际需求开发具体的中间件。

Koa 使用 app.use() 方法注册中间件，并按照注入顺序将其添加到 middleware 数组，这些中间件常用于对 HTTP 请求进行加工处理，比如生成缓存、指定代理以及重定向等。

	const Koa = require('koa');
	const app = new Koa();
	
	// response
	app.use(ctx => {
	    ctx.body = 'Hello Koa';
	});
	
	app.listen(3000)

来源：<a href = 'http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501579966ab03decb0dd246e1a6799dd653a15e1b000'>廖雪峰的官方网站</a>
## 二、koa2

### 1. Middleware

Koa2 支持以下三种中间件函数：

	// common function 
	app.use((ctx, next) => {
	    const start = new Date();
	    return next().then(() => {
	        const ms = new Date() - start;
	        console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
	    });
	});
	
	// async function
	app.use(async (ctx, next) => {
	    const start = new Date();
	    await next();
	    const ms = new Date() - start;
	    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
	});
	
	// generator function
	.use(co.wrap(function *(ctx, next) {
	    const start = new Date();
	    yield next();
	    const ms = new Date() - start;
	    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
	}));

由于 Node.js 尚未支持 async 函数，所以需要使用 Babel 预编译 JS 文件，我的做法是安装依赖 babel-core babel-polyfill babel-preset-es2015 babel-preset-stage-0 ，然后在真实的入口文件（比如 index.js ）前设置一个加载 Babel 的伪入口文件（比如 index.babel.js ），将来 Node.js 支持 Async 后删除该文件即可：

中间件固定接收 (ctx, next) 两个参数，如果要传入其他参数，可以对中间件重新打包：

使用中间件 koa-compose 可以合并多个中间件：

	const compose = require('koa-compose');
	
	async function random(ctx, next) {
	    // ...
	};
	
	async function backwards(ctx, next) {
	    // ...
	};
	
	async function pi(ctx, next) {
	    // ...
	};
	
	const all = compose([random, backwards, pi]);
	
	app.use(all);

Error Handling

Koa 提供了默认的错误处理机制，包括 try-catch 和 Error 事件。自定义 try-catch 捕获的推荐方式如下所示：

	app.use(async (ctx, next) => {
	    try {
	        await next();
	    } catch (err) {
	        err.status = err.statusCode || err.status || 500;
	        throw err;
	    }
	});	

自定义监听 Error 事件：

	app.on('error', (err, ctx) {
	    //  ...
	});

### 2. Koa Instance

Koa 的实例 app 包含以下属性：

- app.name ，可选，为应用程序指定名称
- app.env ，默认值为 NODE_ENV 或 “development”
- app.proxy
- app.subdomainOffset
- app.context ，Koa 推荐使用该命名空间挂载数据

	app.context.db = db();

包含以下方法：
- app.listen() ，设置监听端口
- app.callback()
- app.use() ，注入中间件
- app.keys= ，设置 Signed Cookie 的密钥

### 3. Contex
每一个请求都有一个 Context 对象，该对象又包含 request 和 response 两个对象：

	app.use(async (ctx, next) => {
	    // Context
	    ctx; 
	    // Request
	    ctx.request; 
	    // Response
	    ctx.response; 
	});
	
Context 对象包含的属性：

- ctx.req ，Node.js 的 request 对象
- ctx.res ，Node.js 的 response 对象
- ctx.request ，koa 的 request 对象
- ctx.response ，koa 的 response 对象
- ctx.state ，建议将全局状态挂载在该命名空间下
- ctx.app ，对应用实例的引用

Context 对象包含以下方法：

- ctx.cookies.get(name, [options]) ，获取 cookies
- ctx.cookies.set(name, value, [options]) ，设置 cookies
- ctx.throw([msg], [status], [properties]) ，抛出错误

抛出错误

	ctx.throw('name required', 400);
	
	// 等同于
	const err = new Error('name required');
	err.status = 400;
	throw err;

### 4. Request

该对象是对 Node 原生 Request 对象的再封装，包含以下只读属性：

- request.href
- request.stale
- request.fresh ，判断内容是否已经更新
- request.origin
- request.secure ，检查是否是 HTTPS 协议
- request.charset
- request.originalUrl
- request.type ，获取 Content-Type
- request.header ，等同于 request.headers
- request.length ，返回请求头信息中 Content-Length 的值，如果不存在，则返回 undefined
- request.host ，包含主机名和端口号，如果 app.proxy 的值为 true，则支持 X-Forwarded-Host
- request.protocol ，如果 app.proxy 的值为 true，则支持 X-Forwarded-Host
- request.hostanme ，如果 app.proxy 的值为 true，则支持 X-Forwarded-Host
- request.ip ，如果 app.proxy 的值为 true，则支持 X-Forwarded-Host
- request.ips ，仅当 app.proxy 为 true 时返回 X-Forwarded-Host 列表，否则返回空数组
- request.subdomains ，根据 app.subdomainOffset 返回子域名

包含以下可读写属性：

- request.url
- request.path
- request.method
- request.search
- request.querystring
- request.query

包含以下方法：

- request.is(type...) ，判断 Content-Type 的类型，如果不存在 request.body ，返回undefined；如果没有符合的类型，返回 false；存在符合的类型则返回响应的字符串
- request.accepts(types)
- request.acceptsEncodings(types)
- request.acceptsCharsets(charsets)
- request.acceptsLanguages(langs)

request.is()用法如下：

	// With Content-Type: text/html; charset=utf-8
	ctx.is('html'); 
	// => 'html'
	ctx.is('text/html'); 
	// => 'text/html'
	ctx.is('text/*', 'text/html'); 
	// => 'text/html'
	
	// When Content-Type is application/json
	ctx.is('json', 'urlencoded'); 
	// => 'json'
	ctx.is('application/json'); 
	// => 'application/json'
	ctx.is('html', 'application/*'); 
	// => 'application/json'
	
	ctx.is('html'); 
	// => false

### 5. Response

该对象是对 Node 原生 Response 对象的再封装，包含以下只读属性

- response.socket
- response.header ，等同于 response.headers
- response.headerSent ，检查响应头是否已发送
包含以下可读写属性：

- response.stauts
- response.message
- response.length
- response.body
- response.type
- response.lastModified
- response.etag



	tx.response.etag = crypto.createHash('md5').update(ctx.body).digest('hex');

包含以下方法：

- response.get(field)
- response.set(fields)
- response.vary(field)
- response.set(field, value)
- response.append(field, value)
- response.remove(field)
- response.is(types...)
- response.flushHeaders()
- response.redirect(url, [alt])
- response.attachment([filename]) ，将 Content-Disposition 设为 attachment ，并通知客户端下载资源

来源： <a href = 'http://www.tuicool.com/articles/qYFnUzN' target = '_blank'>推酷</a>
	




