---
layout: post
title: "node.js系列笔记—koa2 中间件开发和使用 "
date: 2017-07-06
excerpt: "koa2支持generator和async两种方式创建的中间件"
tag:
- Koa2
- node.js

comments: false
---

## 一、koa中间件开发和使用：

#### 1. generator 中间件开发
> generator中间件返回的应该是function * ()函数

	/* ./middleware/logger-generator.js */
	function log( ctx ) {
	    console.log( ctx.method, ctx.header.host + ctx.url )
	}
	
	module.exports = function () {
	    return function * ( next ) {
	
	        // 执行中间件的操作
	        log( this )
	
	        if ( next ) {
	            yield next
	        }
	    }
	}

#### 2.generator中间件在koa@1中的使用
> generator 中间件在koa v1中可以直接use使用

	const koa = require('koa')  // koa v1
	const loggerGenerator  = require('./middleware/logger-generator')
	const app = koa()
	
	app.use(loggerGenerator())
	
	app.use(function *( ) {
	    this.body = 'hello world!'
	})
	
	app.listen(3000)
	console.log('the server is starting at port 3000')

#### 3. generator中间件在koa@2中的使用
> generator 中间件在koa v2中需要用koa-convert封装一下才能使用

	const Koa = require('koa') // koa v2
	const convert = require('koa-convert')
	const loggerGenerator  = require('./middleware/logger-generator')
	const app = new Koa()
	
	app.use(convert(loggerGenerator()))
	
	app.use(( ctx ) => {
	    ctx.body = 'hello world!'
	})
	
	app.listen(3000)
	console.log('the server is starting at port 3000')


#### 4. async中间件开发
	/* ./middleware/logger-async.js */
	
	function log( ctx ) {
	    console.log( ctx.method, ctx.header.host + ctx.url )
	}
	
	module.exports = function () {
	  return async function ( ctx, next ) {
	    log(ctx);
	    await next()
	  }
	}
	
	
	
	
#### 5. async 中间件在koa@2中使用
>  async 中间件只能在 koa v2中使用
	
	const Koa = require('koa') // koa v2
	const loggerAsync  = require('./middleware/logger-async')
	const app = new Koa()
	
	app.use(loggerAsync())
	
	app.use(( ctx ) => {
	    ctx.body = 'hello world!'
	})
	
	app.listen(3000)
	console.log('the server is starting at port 3000')
	
参考<a href='https://chenshenhai.github.io/koa2-note/note/start/middleware.html'>来源</a>


## Generator 实例解读

### Generator异步任务的封装

	var fetch = require('node-fetch');
	
	function* gen(){
	  var url = 'https://api.github.com/users/github';
	  var result = yield fetch(url);
	  console.log(result.bio);
	}
执行如下代码：

	var g = gen();
	var result = g.next(); //执行异步任务第一阶段
	
	result.value.then(function(data){
	  return data.json();
	}).then(function(data){
	  g.next(data);
	});
	
由于fetch模块返回的是一个`promise`对象，因此要用`then`方法调用下一个`next`方法
	
可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。



（3）co模块：
co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。

（4）返回值是 Promise。

async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。

进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。


